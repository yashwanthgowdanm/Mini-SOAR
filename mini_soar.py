# -*- coding: utf-8 -*-
"""Mini-SOAR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qpwMZAuhqr-d36oDKXCAuhZeGiun2kbV
"""

# @title Authentication Abuse Detection System (Simulated)
# 1. INSTALL DEPENDENCIES
!pip install Faker -q  # <--- This installs the missing library

# 2. IMPORTS
import pandas as pd
import numpy as np
from faker import Faker
import datetime
from math import radians, cos, sin, asin, sqrt
import matplotlib.pyplot as plt
import seaborn as sns

# Initialize Faker
fake = Faker()
Faker.seed(42)
np.random.seed(42)

# ==========================================
# 1. HELPER FUNCTIONS (Geography & Utils)
# ==========================================

def haversine(lon1, lat1, lon2, lat2):
    """
    Calculate the great circle distance in miles between two points
    on the earth (specified in decimal degrees)
    """
    # convert decimal degrees to radians
    lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])

    # haversine formula
    dlon = lon2 - lon1
    dlat = lat2 - lat1
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * asin(sqrt(a))
    r = 3956 # Radius of earth in miles
    return c * r

# ==========================================
# 2. DATA GENERATION (Simulating Logs)
# ==========================================

def generate_baseline_traffic(num_records=200):
    data = []
    # Common locations (Lat, Lon)
    locations = {
        'NY': (40.7128, -74.0060),
        'London': (51.5074, -0.1278),
        'Tokyo': (35.6762, 139.6503),
        'SF': (37.7749, -122.4194)
    }

    for _ in range(num_records):
        loc_name = np.random.choice(list(locations.keys()))
        loc = locations[loc_name]

        record = {
            'timestamp': fake.date_time_between(start_date='-1d', end_date='now'),
            'username': fake.user_name(),
            'source_ip': fake.ipv4(),
            'event': np.random.choice(['Login Success', 'Login Failed'], p=[0.9, 0.1]),
            'lat': loc[0],
            'lon': loc[1],
            'mfa_status': 'N/A'
        }
        data.append(record)
    return pd.DataFrame(data)

def inject_attacks(df):
    attacks = []
    base_time = datetime.datetime.now()

    # --- Attack A: Password Spraying ---
    # 1 IP trying 30 different users rapidly
    attacker_ip = "192.168.66.6"
    for i in range(30):
        attacks.append({
            'timestamp': base_time + datetime.timedelta(seconds=i*2),
            'username': f"victim_user_{i}",
            'source_ip': attacker_ip,
            'event': 'Login Failed',
            'lat': 40.7128, 'lon': -74.0060, # NY
            'mfa_status': 'N/A'
        })

    # --- Attack B: MFA Fatigue ---
    # 1 User, many denies, finally success
    victim = "executive_john"
    fatigue_ip = "10.0.0.5"
    for i in range(8):
        attacks.append({
            'timestamp': base_time + datetime.timedelta(seconds=i*10),
            'username': victim,
            'source_ip': fatigue_ip,
            'event': 'MFA Request',
            'lat': 37.7749, 'lon': -122.4194, # SF
            'mfa_status': 'Denied'
        })
    # The final accidental acceptance
    attacks.append({
        'timestamp': base_time + datetime.timedelta(seconds=90),
        'username': victim,
        'source_ip': fatigue_ip,
        'event': 'MFA Request',
        'lat': 37.7749, 'lon': -122.4194,
        'mfa_status': 'Approved'
    })

    # --- Attack C: Impossible Travel ---
    # Login NY, then Login London 1 hour later
    traveler = "traveling_tom"
    # Login 1: NY
    attacks.append({
        'timestamp': base_time - datetime.timedelta(hours=2),
        'username': traveler,
        'source_ip': "1.1.1.1",
        'event': 'Login Success',
        'lat': 40.7128, 'lon': -74.0060, # NY
        'mfa_status': 'Approved'
    })
    # Login 2: London (3400 miles away) 1 hour later
    attacks.append({
        'timestamp': base_time - datetime.timedelta(hours=1),
        'username': traveler,
        'source_ip': "2.2.2.2",
        'event': 'Login Success',
        'lat': 51.5074, 'lon': -0.1278, # London
        'mfa_status': 'Approved'
    })

    attack_df = pd.DataFrame(attacks)
    return pd.concat([df, attack_df]).reset_index(drop=True)

# ==========================================
# 3. DETECTION ENGINES
# ==========================================

def detect_password_spraying(df):
    print("\nðŸ”µ DETECTING: Password Spraying...")
    # Filter for Login Failures
    failures = df[df['event'] == 'Login Failed'].copy()

    # Group by IP and count UNIQUE usernames
    spray_candidates = failures.groupby('source_ip')['username'].nunique().reset_index()
    spray_candidates.columns = ['source_ip', 'unique_users_targeted']

    # Threshold: More than 10 unique users targeted from one IP
    detected = spray_candidates[spray_candidates['unique_users_targeted'] > 10]

    if not detected.empty:
        print(f"âš ï¸ ALERT: Potential Password Spraying detected from IPs:")
        print(detected)
    else:
        print("No Spraying Detected.")

def detect_mfa_fatigue(df):
    print("\nðŸ”µ DETECTING: MFA Fatigue...")
    # Filter for MFA events
    mfa_events = df[df['event'] == 'MFA Request'].copy()
    mfa_events = mfa_events.sort_values(by=['username', 'timestamp'])

    # Calculate previous status for logic
    mfa_events['prev_status'] = mfa_events.groupby('username')['mfa_status'].shift(1)

    # Logic: Look for users with > 5 Denials within a short window (simplified here by count)
    counts = mfa_events[mfa_events['mfa_status'] == 'Denied'].groupby('username').size()
    fatigued_users = counts[counts > 5].index.tolist()

    for user in fatigued_users:
        user_logs = mfa_events[mfa_events['username'] == user]
        # Check if a success followed the failures
        if 'Approved' in user_logs['mfa_status'].values:
            print(f"âš ï¸ ALERT: MFA Fatigue & Compromise detected for user: {user}")
            print(f"   Logic: {len(user_logs)} requests found including final approval.")

def detect_impossible_travel(df):
    print("\nðŸ”µ DETECTING: Impossible Travel...")
    success_logins = df[df['event'] == 'Login Success'].copy().sort_values(by=['username', 'timestamp'])

    # Create shifted columns to compare current row with previous row for same user
    success_logins['prev_lat'] = success_logins.groupby('username')['lat'].shift(1)
    success_logins['prev_lon'] = success_logins.groupby('username')['lon'].shift(1)
    success_logins['prev_time'] = success_logins.groupby('username')['timestamp'].shift(1)

    # Remove first logins (no previous data)
    success_logins = success_logins.dropna(subset=['prev_lat'])

    suspicious_travel = []

    for index, row in success_logins.iterrows():
        # Calculate distance (miles)
        dist = haversine(row['lon'], row['lat'], row['prev_lon'], row['prev_lat'])

        # Calculate time difference (hours)
        time_diff = (row['timestamp'] - row['prev_time']).total_seconds() / 3600

        if time_diff > 0 and dist > 0:
            speed = dist / time_diff # Miles per hour

            # Threshold: Speed > 500mph is generally impossible/improbable
            if speed > 500:
                suspicious_travel.append({
                    'User': row['username'],
                    'From_IP': "Previous Session", # Simplified for display
                    'To_IP': row['source_ip'],
                    'Distance_Miles': round(dist, 2),
                    'Time_Hours': round(time_diff, 2),
                    'Speed_MPH': round(speed, 2)
                })

    if suspicious_travel:
        print(f"âš ï¸ ALERT: Impossible Travel detected:")
        print(pd.DataFrame(suspicious_travel))

# ==========================================
# 4. EXECUTION
# ==========================================

# 1. Generate Data
print("Generating Synthetic Logs...")
df_clean = generate_baseline_traffic()
df_final = inject_attacks(df_clean)

print(f"Total Logs Analyzed: {len(df_final)}")
print("-" * 30)

# 2. Run Detections
detect_password_spraying(df_final)
detect_mfa_fatigue(df_final)
detect_impossible_travel(df_final)

# @title 5. Visualization (Attack Timeline)
def visualize_attacks(df):
    plt.figure(figsize=(12, 6))

    # Filter for the specific attack events we found
    attacks = df[
        (df['source_ip'] == '192.168.66.6') |
        (df['username'] == 'executive_john') |
        (df['username'] == 'traveling_tom')
    ]

    sns.scatterplot(
        data=attacks,
        x='timestamp',
        y='username',
        hue='event',
        style='event',
        s=100,
        palette='deep'
    )

    plt.title('Detected Attack Timeline', fontsize=15)
    plt.xlabel('Time of Event')
    plt.ylabel('Targeted User')
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.tight_layout()
    plt.show()

visualize_attacks(df_final)

# @title 6. Automated Response (The Mitigation Bot)

def execute_mitigation(df):
    print("\nðŸ›¡ï¸ INITIATING AUTOMATED RESPONSE PROTOCOLS...\n")
    mitigation_audit = []

    # --- MITIGATION 1: BLOCK PASSWORD SPRAYERS ---
    # Re-detecting the IPs
    failures = df[df['event'] == 'Login Failed']
    spray_counts = failures.groupby('source_ip')['username'].nunique()
    # IPs that targeted > 10 unique users
    bad_ips = spray_counts[spray_counts > 10].index.tolist()

    for ip in bad_ips:
        # Simulation of a Firewall API call
        mitigation_audit.append({
            'Threat Detected': 'Password Spraying',
            'Target Entity': ip,
            'Action Taken': 'ðŸ”¥ BLOCK IP (Firewall)',
            'Time': datetime.datetime.now().strftime("%H:%M:%S"),
            'Outcome': 'Success'
        })

    # --- MITIGATION 2: LOCK COMPROMISED USERS (MFA FATIGUE) ---
    # Re-detecting the specific pattern: Deny -> Deny -> Approve
    mfa_events = df[df['event'] == 'MFA Request'].sort_values(by=['username', 'timestamp'])
    mfa_events['prev_status'] = mfa_events.groupby('username')['mfa_status'].shift(1)

    # Identify users who approved AFTER a denial (high confidence compromise)
    compromised_users = mfa_events[
        (mfa_events['mfa_status'] == 'Approved') &
        (mfa_events['prev_status'] == 'Denied')
    ]['username'].unique().tolist()

    for user in compromised_users:
        # Simulation of an Identity Provider (IdP) API call
        mitigation_audit.append({
            'Threat Detected': 'MFA Fatigue / Compromise',
            'Target Entity': user,
            'Action Taken': 'ðŸ”’ LOCK ACCOUNT & RESET SESSIONS',
            'Time': datetime.datetime.now().strftime("%H:%M:%S"),
            'Outcome': 'Success'
        })

    # --- MITIGATION 3: REVOKE SESSIONS (IMPOSSIBLE TRAVEL) ---
    # Simplified Logic: If speed > 500mph, revoke the *newest* session
    # (Re-using the logic from detection for simplicity)
    success_logins = df[df['event'] == 'Login Success'].sort_values(by=['username', 'timestamp'])
    success_logins['prev_lat'] = success_logins.groupby('username')['lat'].shift(1)
    success_logins['prev_lon'] = success_logins.groupby('username')['lon'].shift(1)
    success_logins['prev_time'] = success_logins.groupby('username')['timestamp'].shift(1)
    success_logins = success_logins.dropna(subset=['prev_lat'])

    for index, row in success_logins.iterrows():
        dist = haversine(row['lon'], row['lat'], row['prev_lon'], row['prev_lat'])
        time_diff = (row['timestamp'] - row['prev_time']).total_seconds() / 3600
        if time_diff > 0 and (dist / time_diff) > 500:
            mitigation_audit.append({
                'Threat Detected': 'Impossible Travel',
                'Target Entity': row['username'],
                'Action Taken': 'ðŸš« REVOKE ACTIVE TOKEN (Session)',
                'Time': datetime.datetime.now().strftime("%H:%M:%S"),
                'Outcome': 'Success'
            })

    # --- OUTPUT THE REPORT ---
    if mitigation_audit:
        audit_df = pd.DataFrame(mitigation_audit)
        print("âœ… Mitigation Complete. Summary Report:")
        display(audit_df) # 'display' prints pretty tables in Colab
    else:
        print("No threats met the threshold for automated mitigation.")

# Execute the Bot
execute_mitigation(df_final)